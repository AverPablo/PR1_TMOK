# -*- coding: utf-8 -*-
"""01_Read_clean_and_validate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o9_csLmzEGnnqHluxPCBXcDiKcwYPCTs

# Read, clean, and validate

## DataFrames and Series

### Exploring the NSFG data
"""

import pandas as pd  # Импортируем библиотеку pandas, которая используется для работы с данными в виде таблиц (DataFrame).
import numpy as np   # Импортируем библиотеку numpy, которая предоставляет поддержку для работы с массивами и матрицами, а также математические функции.
import matplotlib.pyplot as plt  # Импортируем модуль pyplot из библиотеки matplotlib, который используется для создания графиков и визуализации данных.

# Читаем данные из HDF5 файла 'nsfg.hdf5' и загружаем их в переменную nsfg
# 'nsfg' - это имя набора данных внутри HDF5 файла
nsfg = pd.read_hdf('nsfg.hdf5', 'nsfg')

# Отображаем количество строк и столбцов в DataFrame nsfg
print(nsfg.shape)

# Отображаем имена столбцов в DataFrame nsfg
print(nsfg.columns)

# Выбираем столбец 'birthwgt_oz1' из DataFrame nsfg и сохраняем его в переменной ounces
ounces = nsfg['birthwgt_oz1']

# Печатаем первые 5 элементов из переменной ounces
print(ounces.head(5))

"""## Clean and Validate

### Clean a variable
"""

# Подсчитываем количество уникальных значений в столбце 'nbrnaliv' DataFrame nsfg
nsfg['nbrnaliv'].value_counts()

# Заменяем значение 8 на NaN в столбце 'nbrnaliv' DataFrame nsfg
nsfg['nbrnaliv'].replace([8], np.nan, inplace=True)

# Печатаем значения и их частоты в столбце 'nbrnaliv'
print(nsfg['nbrnaliv'].value_counts())

"""### Compute a variable"""

# Получаем статистическое описание столбца 'agecon' DataFrame nsfg
nsfg['agecon'].describe()

# Получаем статистическое описание столбца 'agepreg' DataFrame nsfg
nsfg['agepreg'].describe()

# Выбираем столбцы 'agecon' и 'agepreg' из DataFrame nsfg и делим их значения на 100
agecon = nsfg['agecon'] / 100
agepreg = nsfg['agepreg'] / 100

# Вычисляем разницу между возрастом на момент беременности и возрастом на момент зачатия
preg_length = agepreg - agecon

# Вычисляем сводную статистику для полученной разницы
print(preg_length.describe())

"""## Filter and visualize

### Make a histogram
"""

# Строим гистограмму для возраста на момент зачатия
plt.hist(agecon, bins=20)

# Подписываем оси графика
plt.xlabel("Age at conception")
plt.ylabel('Number of pregnancies')

# Строим гистограмму для возраста на момент зачатия с типом 'step'
plt.hist(agecon, bins=20, histtype='step')

# Подписываем оси графика
plt.xlabel("Age at conception")
plt.ylabel('Number of pregnancies')

"""### Compute birth weight"""

def resample_rows_weighted(df, column='wgt2013_2015'):
    """Resamples a DataFrame using probabilities proportional to given column.
    Args:
        df: DataFrame
        column: string column name to use as weights
    returns:
        DataFrame
    """
    # Копируем значения из указанного столбца весов
    weights = df[column].copy()

    # Нормализуем веса, деля каждое значение на сумму всех весов
    weights /= sum(weights)

    # Выбираем индексы строк из DataFrame с учетом весов, с заменой
    indices = np.random.choice(df.index, len(df), replace=True, p=weights)

    # Создаем новый DataFrame, используя выбранные индексы
    sample = df.loc[indices]

    # Возвращаем новый DataFrame с выборкой
    return sample

# Resample the data
nsfg = resample_rows_weighted(nsfg, 'wgt2013_2015')
# Здесь мы вызываем функцию resample_rows_weighted, чтобы выполнить выборку строк из DataFrame nsfg,
# используя веса из столбца 'wgt2013_2015'. Результат сохраняется обратно в переменную nsfg.

# Clean the weight variables
pounds = nsfg['birthwgt_lb1'].replace([98, 99], np.nan)
# В этой строке мы извлекаем данные о весе при рождении в фунтах из столбца 'birthwgt_lb1'
# и заменяем специальные коды 98 и 99 на NaN (отсутствующие значения), чтобы очистить данные.

ounces = nsfg['birthwgt_oz1'].replace([98, 99], np.nan)
# Аналогично, здесь мы извлекаем данные о весе при рождении в унциях из столбца 'birthwgt_oz1'
# и также заменяем специальные коды 98 и 99 на NaN для очистки данных.

# Compute total birth weight
birth_weight = pounds + ounces/16
# Здесь мы вычисляем общий вес при рождении, складывая вес в фунтах и вес в унциях,
# предварительно преобразованный в фунты (1 унция = 1/16 фунта). Результат сохраняется в переменной birth_weight.

# Create a Boolean Series for full-term babies
full_term = nsfg['prglngth'] >= 37
# В этой строке мы создаем логическую серию (Boolean Series), которая будет содержать True для всех
# записей, где длина беременности (столбец 'prglngth') составляет 37 недель или больше,
# что соответствует полным срокам беременности.

# Select the weights of full-term babies
full_term_weight = birth_weight[full_term]
# Здесь мы используем логическую серию 'full_term' для фильтрации весов при рождении
# из переменной 'birth_weight', оставляя только веса для полнородных детей.

# Compute the mean weight of full-term babies
print(full_term_weight.mean())
# В этой строке мы вычисляем средний вес полнородных детей, используя метод mean()
# и выводим результат на экран.

"""### Filter"""

# Filter full-term babies
full_term = nsfg['prglngth'] >= 37
# В этой строке создается логическая серия, которая определяет, какие дети родились в полном сроке,
# основываясь на столбце 'prglngth', где значение 37 недель или больше указывает на полноценную беременность.

# Filter single birth
single = nsfg['nbrnaliv'] == 1
# Здесь создается еще одна логическая серия, которая определяет, родился ли ребенок в результате
# единственной беременности, используя столбец 'nbrnaliv', где значение 1 указывает на единственного
# живорожденного.

# Compute birth weight for single full-term babies
single_full_term_weight = birth_weight[single & full_term]
# В этой строке мы фильтруем веса при рождении, оставляя только тех детей, которые
# были рождены в полных сроках и являются единственными. Это достигается с помощью
# логического оператора 'и' (&), который комбинирует две логические серии.

print('Single full-term mean:', single_full_term_weight.mean())
# Здесь мы вычисляем средний вес для единственных полнородных детей и выводим его на экран.

# Compute birth weight for multiple full-term babies
mult_full_term_weight = birth_weight[~single & full_term]
# В этой строке мы фильтруем веса при рождении для многоплодных полнородных детей,
# используя логический оператор 'не' (~) для выбора тех, кто не является единственным
# живорожденным, и комбинируем это с условием по полной беременности.

print('Multiple full-term mean:', mult_full_term_weight.mean())
# Здесь мы вычисляем средний вес для многоплодных полнородных детей и выводим его на экран.